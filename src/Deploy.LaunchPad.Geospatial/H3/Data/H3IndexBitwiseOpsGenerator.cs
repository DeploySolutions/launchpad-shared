// SPDX-License-Identifier: Apache-2.0
//
// This file contains code originally from the H3.net project:
//   Repository: https://github.com/pocketken/H3.net/
//   Original license: Apache License, Version 2.0
//
// Modifications in this forked/copied version:
//   - Integrated into Deploy.LaunchPad.Geospatial (namespace adjustments)
//   - Local fixes and adaptations (see git history for details)
//
// Original Copyright (c) Ken March (pocketken), https://github.com/pocketken
// Modified files Copyright (c) Deploy Software Solutions, 2026
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Deploy.LaunchPad.Geospatial.H3.Data; 

// TODO rename this to H3IndexBitwiseRotationOpsGenerator?

[Generator]
public partial class H3IndexBitwiseOpsGenerator : IIncrementalGenerator
{

    private static readonly string _indent = string.Empty.PadLeft(12, ' ');

    private const string TEMPLATE = @"// <auto-generated/>
using H3.Model;
using System.Runtime.CompilerServices;

namespace H3;

public sealed partial class H3Index {{

    /// <summary>
    /// Perform in-place 60 degree clockwise rotation(s) of the index.
    /// </summary>
    /// <param name=""rotations"">number of rotations to perform</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RotateClockwise(int rotations) {{
        if (rotations <= 0) return;
        Value = Resolution switch {{{0}
            _ => Value
        }};
    }}

    /// <summary>
    /// Perform in-place 60 degree clockwise rotation(s) of the index.
    /// </summary>
    /// <param name=""rotations"">number of rotations to perform</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RotateCounterClockwise(int rotations) {{
        if (rotations <= 0) return;
        Value = Resolution switch {{{1}
            _ => Value
        }};
    }}

}}";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the source generation logic
        context.RegisterSourceOutput(
            context.CompilationProvider,
            (sourceProductionContext, compilation) =>
            {
                // Generate the source code
                var source = GenerateSource();
                sourceProductionContext.AddSource("H3Index.BitwiseOperations.g.cs", SourceText.From(source, Encoding.UTF8));
            });
    }

    private string GenerateSource()
    {
        var rotateHexCw = new StringBuilder();
        var rotateHexCcw = new StringBuilder();

        for (var r = 1; r <= 15; r += 1)
        {
            var mask = ~0UL;
            mask <<= 3 * r;
            mask = ~mask;
            mask <<= 3 * (15 - r);
            mask = ~mask;

            rotateHexCw.Append($"\r\n            {r} => (Value & {mask}UL) |\r\n");
            rotateHexCcw.Append($"\r\n            {r} => (Value & {mask}UL) |\r\n");

            for (var c = 1; c <= r; c += 1)
            {
                var offset = (15 - c) * 3;
                var eol = c == r ? "," : " |\r\n";
                rotateHexCw.Append($"                ((ulong)((Direction)((Value >> {offset}) & H3_DIGIT_MASK)).RotateClockwise(rotations) << {offset}){eol}");
                rotateHexCcw.Append($"                ((ulong)((Direction)((Value >> {offset}) & H3_DIGIT_MASK)).RotateCounterClockwise(rotations) << {offset}){eol}");
            }
        }

        return string.Format(TEMPLATE, rotateHexCw, rotateHexCcw);
    }

    public void Execute(GeneratorExecutionContext context) {
        var rotateHexCw = new StringBuilder();
        var rotateHexCcw = new StringBuilder();

        for (var r = 1; r <= 15; r += 1) {
            var mask = ~0UL;
            mask <<= 3 * r;
            mask = ~mask;
            mask <<= 3 * (15 - r);
            mask = ~mask;

            rotateHexCw.Append($"\r\n{_indent}{r} => (Value & {mask}UL) |\r\n");
            rotateHexCcw.Append($"\r\n{_indent}{r} => (Value & {mask}UL) |\r\n");

            for (var c = 1; c <= r; c += 1) {
                var offset = (15 - c) * 3;
                var eol = c == r ? "," : " |\r\n";
                rotateHexCw.Append($"{_indent}    ((ulong)((Direction)((Value >> {offset}) & H3_DIGIT_MASK)).RotateClockwise(rotations) << {offset}){eol}");
                rotateHexCcw.Append($"{_indent}    ((ulong)((Direction)((Value >> {offset}) & H3_DIGIT_MASK)).RotateCounterClockwise(rotations) << {offset}){eol}");
            }
        }

        context.AddSource("H3Index.BitwiseOperations.g.cs", string.Format(TEMPLATE, rotateHexCw, rotateHexCcw));
    }

}